{"content":{"out":{"attributes":{"title":"Lifetime is so goodd!!!","date":"2021-06-10"},"body":"<p>The lifetime parameter in a function/object is something that I had never seen before (I have used a lot of programming languages though). The way that <em><strong>Rust</strong></em>(Yes, I will bold and italicize every time I write <em><strong>Rust</strong></em>) has the concept of lifetime wasn&#39;t that initiative to me at first; I spent a good amount of time trying to understand the basics of lifetime and here is what I have understood; these are just the surface of a mammoth iceberg. </p>\n<p>Lifetime are useful when we pass arguments through reference. Lifetime parameters are required to tell the compiler in <em>whose</em> lifetime should the value returned by reference should exist in. Before talking about  lifetimes let&#39;s look at what a dangling pointer is. </p>\n<p>Let&#39;s first look at a C++ example:</p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span>&amp; <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>&amp; x, <span class=\"hljs-type\">int</span>&amp; y)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (x &lt; y) {\n        <span class=\"hljs-keyword\">return</span> x;\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">return</span> y;\n    }\n}\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">20</span>;\n    <span class=\"hljs-type\">int</span> *p;\n    {\n        <span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">10</span>;\n        p = &amp;<span class=\"hljs-built_in\">foo</span>(a,b);\n        std::cout &lt;&lt; &amp;b &lt;&lt; std::endl;\n    }\n    std::cout &lt;&lt; p &lt;&lt; std::endl;\n}\n</code></pre>\n<pre><code>Output: 0x7ffee8693884\n    0x7ffee8693884\n</code></pre>\n<p> The above problem looks deliberate and it is; this is a classic example of dangling pointer. The pointer <code>*p</code> refers to the memory address the <code>b</code> used to point to. This can sort of behavior is undefined, in my particular system <code>*p</code> points to the original value of <code>b</code>. </p>\n<p>Now, let&#39;s see how   <em><strong>Rust</strong></em> hopes to solve such dangling pointers. Let&#39;s look at an example:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">foo</span>(x: &amp;<span class=\"hljs-type\">i32</span>, y: &amp;<span class=\"hljs-type\">i32</span>) <span class=\"hljs-punctuation\">-&gt;</span> &amp;<span class=\"hljs-type\">i32</span> {\n    <span class=\"hljs-keyword\">if</span> x &lt; y {\n        x\n    } <span class=\"hljs-keyword\">else</span> {\n        y\n    }\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">k</span>: <span class=\"hljs-type\">i32</span> = <span class=\"hljs-number\">100</span>;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">_x</span>;\n    {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">p</span>: <span class=\"hljs-type\">i32</span> = <span class=\"hljs-number\">200</span>;\n        _x = <span class=\"hljs-title function_ invoke__\">foo</span>(&amp;k, &amp;p);\n    }\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;{}&quot;</span>,_x);\n}\n</code></pre>\n<p>This will not compile. The compiler will give us an error that  the lifetime of the reference is ambiguous as <em><strong>Rust</strong></em> doesn&#39;t know what the lifetime of the reference is. Let&#39;s add the lifetime, shall we?</p>\n<p>Lifetime is the, as the name suggests, tells the compiler up to whose lifetime the returned value should exist. Lifetime is declared as a generic parameter in function name: <code>fn foo&lt;&#39;a&gt;</code>. This tells the compiler that there is a lifetime <code>&#39;a </code> such that the reference returned exists in it. It&#39;s complicated for me to explain it, here is an example:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">foo</span>&lt;<span class=\"hljs-symbol\">&#x27;a</span>&gt;(x: &amp;<span class=\"hljs-symbol\">&#x27;a</span> <span class=\"hljs-type\">i32</span>, y: &amp;<span class=\"hljs-symbol\">&#x27;a</span> <span class=\"hljs-type\">i32</span>) <span class=\"hljs-punctuation\">-&gt;</span> &amp;<span class=\"hljs-symbol\">&#x27;a</span> <span class=\"hljs-type\">i32</span> {\n    <span class=\"hljs-keyword\">if</span> x &lt; y {\n        x\n    } <span class=\"hljs-keyword\">else</span> {\n        y\n    }\n}\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">k</span>: <span class=\"hljs-type\">i32</span> = <span class=\"hljs-number\">100</span>;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">_x</span>;\n    {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">p</span>: <span class=\"hljs-type\">i32</span> = <span class=\"hljs-number\">200</span>;\n        _x = <span class=\"hljs-title function_ invoke__\">foo</span>(&amp;k, &amp;p);\n    }\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;{}&quot;</span>,_x);\n}\n</code></pre>\n<p>The above code tells the compiler: Please find a lifetime <code>&#39;a</code> such that no dangling pointer is formed. Here, we are explicitly saying the compiler that there is a lifetime <code>&#39;a</code> such that the entire program is valid. Here, it look fine. The function <code>foo()</code> gets two reference and since k is smaller than p, returns reference to <code>k</code> right? Sadly this is wrong.</p>\n<p>Remember the time I said <em><strong>Rust</strong></em> is strict, I really meant it. Since all three of them ,the two parameters and the reference return,have been explicitly declared to be available in a lifetime <code>&#39;a</code>, the compiler searches for such lifetime. However, this isn&#39;t available here. The variable <code>p</code> goes out of scope at the end of the closing curly bracket after the two lines, and <code>_x</code> is still being used after the lifetime of <code>p</code>, this might cause a dangling pointer, so <em><strong>Rust</strong></em> just gives an Error!! Even though <code>_x</code> points to <code>k</code>, the lifetime of reference returned to <code>_x</code> is the lifetime of smallest parameter that is passed in the function.  </p>\n<p>So to fix this code, we could have restructure the code:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">foo</span>&lt;<span class=\"hljs-symbol\">&#x27;a</span>&gt;(x: &amp;<span class=\"hljs-symbol\">&#x27;a</span> <span class=\"hljs-type\">i32</span>, y: &amp;<span class=\"hljs-symbol\">&#x27;a</span> <span class=\"hljs-type\">i32</span>) <span class=\"hljs-punctuation\">-&gt;</span> &amp;<span class=\"hljs-symbol\">&#x27;a</span> <span class=\"hljs-type\">i32</span> {\n    <span class=\"hljs-keyword\">if</span> x &lt; y {\n        x\n    } <span class=\"hljs-keyword\">else</span> {\n        y\n    }\n}\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">k</span>: <span class=\"hljs-type\">i32</span> = <span class=\"hljs-number\">100</span>;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">_x</span>;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">p</span>: <span class=\"hljs-type\">i32</span> = <span class=\"hljs-number\">200</span>;\n    _x = <span class=\"hljs-title function_ invoke__\">foo</span>(&amp;k, &amp;p);\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;{}&quot;</span>,_x);\n}\n</code></pre>\n<p>This will work as <code>_x</code> is available for the entire lifetime of the smallest lifetime of the parameter to the function from where it gets its reference return. </p>\n<p>Or, something like this.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">foo</span>&lt;<span class=\"hljs-symbol\">&#x27;a</span>&gt;(x: &amp;<span class=\"hljs-symbol\">&#x27;a</span> <span class=\"hljs-type\">i32</span>, y: &amp;<span class=\"hljs-symbol\">&#x27;a</span> <span class=\"hljs-type\">i32</span>) <span class=\"hljs-punctuation\">-&gt;</span> &amp;<span class=\"hljs-symbol\">&#x27;a</span> <span class=\"hljs-type\">i32</span> {\n    <span class=\"hljs-keyword\">if</span> x &lt; y {\n        x\n    } <span class=\"hljs-keyword\">else</span> {\n        y\n    }\n}\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">k</span>: <span class=\"hljs-type\">i32</span> = <span class=\"hljs-number\">100</span>;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">p</span>;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">x_ref</span>;\n    {\n        p: <span class=\"hljs-type\">i32</span> = <span class=\"hljs-number\">200</span>;\n        x_ref = <span class=\"hljs-title function_ invoke__\">foo</span>(&amp;k, &amp;p);\n    }\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;{}&quot;</span>, x_ref);\n}\n</code></pre>\n<p>Here, the returned reference exists for the entire lifetime of <code>k</code>.</p>\n<p>The lifetime of returned reference type should be one of parameter&#39;s lifetime. If the lifetime on the returned type isn&#39;t the lifetime one of the function parameter, it is an error.</p>\n<p>This is a very bad, high level overview of lifetime, great amount of features about lifetime are yet to be discussed. You can read more about it from the references below:</p>\n<ul>\n<li><a href=\"https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html\" target='_blank'>The Rust Programming Language Book (Chapter 10)</a> </li>\n<li><a href=\"https://doc.rust-lang.org/rust-by-example/scope/lifetime/explicit.html\" target='_blank'>Rust by Example (Explicit Annotations)</a></li>\n</ul>\n","bodyBegin":6,"frontmatter":"title: Lifetime is so goodd!!!\ndate: 2021-06-10"},"prev":{"link":"2021-06-08-rust_bust","blog":{"date":"2021-06-08","title":"Rust Bust"}},"next":{"link":"2021-06-21-random_or_not_to_be_random","blog":{"date":"2021-06-21","title":"Random Or Not to be Random"}}}}